<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÄ</text></svg>" />
    <title>Decoradores en Python</title>
    <link rel="stylesheet" href="../styles/styles.css">
</head>
<body>
    <header>
        <h1>Decoradores en Python</h1>
        <p>Modificaci√≥n y Extensi√≥n de Funciones y Clases</p>
    </header>

    <nav>
        <a href="../index.html">‚Üê Volver al √≠ndice</a>
    </nav>

    <div class="container">
        <section>
            <h2>¬øQu√© son los Decoradores?</h2>
            <p>Los decoradores son una caracter√≠stica poderosa de Python que permite modificar o extender el comportamiento de funciones o clases sin modificar directamente su c√≥digo. Son un ejemplo del patr√≥n de dise√±o Decorator, que permite a√±adir funcionalidad de manera din√°mica.</p>

            <p>En esencia, un decorador es una funci√≥n que toma otra funci√≥n (o clase) como argumento y retorna una nueva funci√≥n (o clase) con funcionalidad adicional. Los decoradores se aplican usando el s√≠mbolo @ seguido del nombre del decorador justo encima de la definici√≥n de la funci√≥n o clase que se quiere decorar.</p>

            <p>Los decoradores son ampliamente utilizados para:</p>
            <ul>
                <li>Logging (registro de ejecuci√≥n)</li>
                <li>Medici√≥n de tiempo de ejecuci√≥n</li>
                <li>Control de acceso y autenticaci√≥n</li>
                <li>Validaci√≥n de par√°metros</li>
                <li>Cacheo de resultados</li>
                <li>Gesti√≥n de transacciones</li>
                <li>Gesti√≥n de recursos</li>
            </ul>
        </section>

        <section>
            <h2>Decoradores de Funciones</h2>
            <p>Los decoradores de funciones son los m√°s comunes y pueden implementarse de varias formas:</p>

            <h3>Decorador Simple</h3>
            <p>Un decorador simple toma una funci√≥n, a√±ade funcionalidad y retorna una nueva funci√≥n:</p>

            <div class="example">
                <pre><code>def registrar(funcion):
    def wrapper(*args, **kwargs):
        print(f"Llamando a {funcion.__name__}")
        resultado = funcion(*args, **kwargs)
        print(f"Finaliz√≥ la llamada a {funcion.__name__}")
        return resultado
    return wrapper

@registrar
def saludar(nombre):
    print(f"¬°Hola, {nombre}!")

# Equivalente a:
# saludar = registrar(saludar)</code></pre>
            </div>

            <h3>Decoradores con Argumentos</h3>
            <p>Los decoradores pueden aceptar argumentos para personalizar su comportamiento:</p>

            <div class="example">
                <pre><code>def repetir(veces):
    def decorador(funcion):
        def wrapper(*args, **kwargs):
            for _ in range(veces):
                resultado = funcion(*args, **kwargs)
            return resultado
        return wrapper
    return decorador

@repetir(veces=3)
def saludar(nombre):
    print(f"¬°Hola, {nombre}!")

# Equivalente a:
# saludar = repetir(veces=3)(saludar)</code></pre>
            </div>
        </section>

        <section>
            <h2>Casos de Uso Comunes</h2>

            <h3>1. Medici√≥n de Tiempo</h3>
            <p>Medir el tiempo de ejecuci√≥n de una funci√≥n:</p>

            <div class="example">
                <pre><code>import time
from functools import wraps

def medir_tiempo(funcion):
    @wraps(funcion)
    def wrapper(*args, **kwargs):
        inicio = time.time()
        resultado = funcion(*args, **kwargs)
        fin = time.time()
        print(f"{funcion.__name__} tom√≥ {fin - inicio:.2f} segundos")
        return resultado
    return wrapper

@medir_tiempo
def operacion_costosa():
    time.sleep(1)  # Simula operaci√≥n lenta</code></pre>
            </div>

            <h3>2. Cach√© de Resultados</h3>
            <p>Almacenar en cach√© los resultados de funciones para evitar c√°lculos repetidos:</p>

            <div class="example">
                <pre><code>def cache(funcion):
    memoria = {}
    @wraps(funcion)
    def wrapper(*args, **kwargs):
        clave = str(args) + str(kwargs)
        if clave not in memoria:
            memoria[clave] = funcion(*args, **kwargs)
        return memoria[clave]
    return wrapper

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)</code></pre>
            </div>

            <h3>3. Validaci√≥n de Argumentos</h3>
            <p>Verificar que los argumentos cumplan ciertas condiciones:</p>

            <div class="example">
                <pre><code>def validar_rango(minimo, maximo):
    def decorador(funcion):
        @wraps(funcion)
        def wrapper(valor):
            if not minimo <= valor <= maximo:
                raise ValueError(f"Valor debe estar entre {minimo} y {maximo}")
            return funcion(valor)
        return wrapper
    return decorador

@validar_rango(0, 100)
def calcular_porcentaje(valor):
    return valor / 100</code></pre>
            </div>
        </section>

        <section>
            <h2>Decoradores de Clase</h2>
            <p>Los decoradores tambi√©n pueden aplicarse a clases para modificar su comportamiento:</p>

            <h3>1. Registro de Clases</h3>
            <div class="example">
                <pre><code>def registro_clase(cls):
    print(f"Registrando clase: {cls.__name__}")
    # Aqu√≠ podr√≠as registrar la clase en alg√∫n sistema
    return cls

@registro_clase
class MiClase:
    pass</code></pre>
            </div>

            <h3>2. Singleton</h3>
            <div class="example">
                <pre><code>def singleton(cls):
    instancias = {}
    def obtener_instancia(*args, **kwargs):
        if cls not in instancias:
            instancias[cls] = cls(*args, **kwargs)
        return instancias[cls]
    return obtener_instancia

@singleton
class BaseDatos:
    def __init__(self):
        self.conexion = "Conectado a la BD"</code></pre>
            </div>
        </section>

        <section>
            <h2>Decoradores Integrados en Python</h2>
            <p>Python incluye varios decoradores √∫tiles en su biblioteca est√°ndar:</p>

            <h3>@property</h3>
            <p>Convierte un m√©todo en un atributo de solo lectura:</p>
            <div class="example">
                <pre><code>class Circulo:
    def __init__(self, radio):
        self._radio = radio

    @property
    def area(self):
        return 3.14159 * self._radio ** 2</code></pre>
            </div>

            <h3>@classmethod</h3>
            <p>Define un m√©todo que opera sobre la clase en lugar de la instancia:</p>
            <div class="example">
                <pre><code>class Fecha:
    def __init__(self, a√±o, mes, dia):
        self.fecha = date(a√±o, mes, dia)

    @classmethod
    def hoy(cls):
        fecha_actual = date.today()
        return cls(fecha_actual.year, 
                  fecha_actual.month, 
                  fecha_actual.day)</code></pre>
            </div>

            <h3>@staticmethod</h3>
            <p>Define un m√©todo que no necesita acceso a la clase ni a la instancia:</p>
            <div class="example">
                <pre><code>class Calculadora:
    @staticmethod
    def es_par(numero):
        return numero % 2 == 0</code></pre>
            </div>
        </section>

        <section>
            <h2>Mejores Pr√°cticas</h2>
            <div class="tip">
                <strong>Recomendaciones para el uso de decoradores:</strong>
                <ul>
                    <li>Usar functools.wraps para preservar metadatos de la funci√≥n original</li>
                    <li>Mantener los decoradores simples y con un prop√≥sito √∫nico</li>
                    <li>Documentar el comportamiento a√±adido por el decorador</li>
                    <li>Considerar el impacto en el rendimiento</li>
                    <li>Manejar correctamente los argumentos y valores de retorno</li>
                    <li>Evitar efectos secundarios no documentados</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Patrones comunes:</strong>
                <ul>
                    <li>Registro de ejecuci√≥n (logging)</li>
                    <li>Control de acceso</li>
                    <li>Validaci√≥n</li>
                    <li>Medici√≥n de rendimiento</li>
                    <li>Gesti√≥n de recursos</li>
                    <li>Cacheo</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>Recursos Adicionales</h2>
            <ul>
                <li><a href="https://docs.python.org/3/glossary.html#term-decorator">Documentaci√≥n oficial de Python sobre decoradores</a></li>
                <li><a href="https://realpython.com/primer-on-python-decorators/">Real Python - Gu√≠a de decoradores</a></li>
                <li><a href="https://www.python.org/dev/peps/pep-0318/">PEP 318 - Decorators for Functions and Methods</a></li>
            </ul>
        </section>
    </div>
</body>
</html>