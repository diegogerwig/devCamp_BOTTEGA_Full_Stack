<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üîÑ</text></svg>" />
    <title>Polimorfismo en Python</title>
    <link rel="stylesheet" href="../styles/styles.css">
</head>
<body>
    <header>
        <h1>Polimorfismo en Python</h1>
        <p>M√∫ltiples Formas, Un Solo Nombre</p>
    </header>

    <nav>
        <a href="../index.html">‚Üê Volver al √≠ndice</a>
    </nav>

    <div class="container">
        <section>
            <h2>¬øQu√© es el Polimorfismo?</h2>
            <p>El polimorfismo es uno de los pilares fundamentales de la programaci√≥n orientada a objetos. La palabra "polimorfismo" viene del griego y significa "muchas formas". En programaci√≥n, se refiere a la capacidad de un objeto para tomar diferentes formas y responder de manera diferente al mismo mensaje o m√©todo.</p>

            <p>En Python, el polimorfismo est√° estrechamente relacionado con su sistema de tipos din√°mico y el principio de "duck typing": si un objeto camina como un pato y hace cuac como un pato, entonces es un pato (metaf√≥ricamente hablando). Esto significa que Python se centra m√°s en el comportamiento de los objetos que en su tipo espec√≠fico.</p>
        </section>

        <section>
            <h2>Tipos de Polimorfismo</h2>

            <h3>1. Polimorfismo de Sobrecarga de Operadores</h3>
            <p>Permite que los operadores realicen diferentes acciones seg√∫n el tipo de los operandos. En Python, esto se implementa mediante m√©todos especiales (dunder methods).</p>
            
            <div class="example">
                <pre><code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# El operador + funciona diferente seg√∫n el tipo
print(5 + 3)         # Suma de n√∫meros: 8
print("Hola " + "Mundo")  # Concatenaci√≥n de strings
v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)       # Suma de vectores: Vector(4, 6)</code></pre>
            </div>

            <h3>2. Polimorfismo de Herencia</h3>
            <p>Permite que las clases derivadas proporcionen una implementaci√≥n espec√≠fica de m√©todos heredados de la clase base. Es fundamental para crear jerarqu√≠as de clases flexibles y extensibles.</p>

            <p>El polimorfismo de herencia permite tratar objetos de diferentes clases derivadas a trav√©s de su interfaz com√∫n (clase base), lo que facilita la extensibilidad y el mantenimiento del c√≥digo.</p>
        </section>

        <section>
            <h2>Duck Typing en Python</h2>
            <p>El duck typing es un concepto fundamental en Python que est√° estrechamente relacionado con el polimorfismo. En lugar de verificar el tipo de un objeto, Python se centra en si el objeto tiene los m√©todos y atributos necesarios.</p>

            <p>Ventajas del duck typing:</p>
            <ul>
                <li><strong>Flexibilidad:</strong> Los objetos solo necesitan implementar los m√©todos requeridos</li>
                <li><strong>Extensibilidad:</strong> Facilita la adici√≥n de nuevos tipos compatibles</li>
                <li><strong>Desacoplamiento:</strong> Reduce la dependencia de tipos espec√≠ficos</li>
                <li><strong>Reusabilidad:</strong> Permite usar c√≥digo con diferentes tipos de objetos</li>
            </ul>

            <div class="example">
                <pre><code>def procesar_datos(coleccion):
    for item in coleccion:  # Solo necesita ser iterable
        print(item)

# Funciona con cualquier iterable
procesar_datos([1, 2, 3])           # Lista
procesar_datos((4, 5, 6))           # Tupla
procesar_datos({"a", "b", "c"})     # Set
procesar_datos({"x": 1, "y": 2})    # Diccionario</code></pre>
            </div>
        </section>

        <section>
            <h2>Polimorfismo en la Pr√°ctica</h2>
            <p>El polimorfismo se utiliza extensamente en Python para crear c√≥digo flexible y reutilizable. Aqu√≠ hay algunos patrones comunes:</p>

            <h3>1. Interfaces Impl√≠citas</h3>
            <p>Python no tiene interfaces formales, pero usa interfaces impl√≠citas a trav√©s del duck typing. Los objetos solo necesitan implementar los m√©todos esperados.</p>

            <h3>2. Clases Abstractas</h3>
            <p>Aunque Python favorece el duck typing, a veces es √∫til definir interfaces expl√≠citas usando clases abstractas:</p>

            <div class="example">
                <pre><code>from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimetro(self):
        pass

class Rectangulo(Figura):
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura
    
    def area(self):
        return self.base * self.altura
    
    def perimetro(self):
        return 2 * (self.base + self.altura)

class Circulo(Figura):
    def __init__(self, radio):
        self.radio = radio
    
    def area(self):
        return 3.14159 * self.radio ** 2
    
    def perimetro(self):
        return 2 * 3.14159 * self.radio</code></pre>
            </div>
        </section>

        <section>
            <h2>Ventajas del Polimorfismo</h2>
            <ul>
                <li><strong>Flexibilidad:</strong> Permite que el c√≥digo funcione con diferentes tipos de objetos</li>
                <li><strong>Extensibilidad:</strong> Facilita la adici√≥n de nuevos tipos sin modificar el c√≥digo existente</li>
                <li><strong>Reutilizaci√≥n:</strong> Promueve la reutilizaci√≥n de c√≥digo a trav√©s de interfaces comunes</li>
                <li><strong>Mantenibilidad:</strong> Hace el c√≥digo m√°s modular y f√°cil de mantener</li>
                <li><strong>Abstracci√≥n:</strong> Permite trabajar con conceptos de alto nivel</li>
            </ul>
        </section>

        <section>
            <h2>Mejores Pr√°cticas</h2>
            <div class="tip">
                <strong>Recomendaciones para usar polimorfismo:</strong>
                <ul>
                    <li>Favorecer interfaces simples y cohesivas</li>
                    <li>Usar duck typing cuando sea apropiado</li>
                    <li>Implementar m√©todos abstractos cuando sea necesario garantizar una interfaz</li>
                    <li>Documentar claramente el comportamiento esperado</li>
                    <li>Mantener la consistencia en las interfaces</li>
                    <li>Evitar verificaciones expl√≠citas de tipo (isinstance) cuando sea posible</li>
                    <li>Usar composici√≥n sobre herencia cuando sea apropiado</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>Recursos Adicionales</h2>
            <ul>
                <li><a href="https://docs.python.org/3/library/abc.html">Documentaci√≥n oficial sobre ABCs</a></li>
                <li><a href="https://www.python.org/dev/peps/pep-3119/">PEP 3119 - Introducing Abstract Base Classes</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a></li>
            </ul>
        </section>
    </div>
</body>
</html>