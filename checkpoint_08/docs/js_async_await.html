<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üü®</text></svg>" />
    <title>Async/Await en JavaScript - Documentaci√≥n</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex flex-col min-h-screen">
    <header class="bg-yellow-600 text-white text-center py-12 px-4 shadow-md fixed top-0 left-0 right-0 z-20">
        <h1 class="text-4xl font-bold mb-2">Async/Await en JavaScript</h1>
        <p class="text-xl">¬øQu√© hacen async y await por nosotros?</p>
    </header>

    <nav class="bg-gray-800 py-4 px-6 shadow-md fixed top-40 left-0 right-0 z-10 border-b border-gray-700">
        <a href="../index.html" class="text-yellow-400 hover:text-yellow-300 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
            Volver al √≠ndice
        </a>
    </nav>

    <div class="pt-56">

        <div class="container mx-auto px-4 py-8 max-w-4xl flex-grow">
            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">¬øQu√© es Async/Await?</h2>
                    <p class="mb-4">Async/await es una sintaxis introducida en ES2017 (ES8) que permite escribir c√≥digo as√≠ncrono de manera que parezca y se comporte como c√≥digo s√≠ncrono. Es una forma m√°s elegante y legible de trabajar con promesas.</p>
                    
                    <div class="bg-gray-900 p-4 rounded-lg mb-6 border border-yellow-700">
                        <h3 class="text-lg font-semibold mb-2 text-yellow-300">Conceptos clave:</h3>
                        <ul class="list-disc pl-6 space-y-2 text-gray-300">
                            <li><strong class="text-white">async:</strong> Palabra clave que se coloca antes de una funci√≥n para indicar que devolver√° una promesa.</li>
                            <li><strong class="text-white">await:</strong> Operador que pausa la ejecuci√≥n de la funci√≥n async hasta que una promesa se resuelva.</li>
                            <li><strong class="text-white">Secuencialidad:</strong> El c√≥digo dentro de una funci√≥n async se ejecuta de manera secuencial (como c√≥digo s√≠ncrono).</li>
                            <li><strong class="text-white">Manejo de errores:</strong> Se puede usar el tradicional try/catch para capturar errores as√≠ncronos.</li>
                            <li><strong class="text-white">Promesas impl√≠citas:</strong> Las funciones async siempre devuelven una promesa, incluso si no lo declaramos expl√≠citamente.</li>
                        </ul>
                    </div>
                    
                    <p class="mb-4">Async/await es fundamentalmente una abstracci√≥n sobre las promesas. No introduce una nueva forma de asincron√≠a en JavaScript, sino que proporciona una sintaxis m√°s limpia y f√°cil de entender para trabajar con c√≥digo as√≠ncrono basado en promesas.</p>
                    
                    <div class="bg-gray-900 p-4 rounded-lg border-l-4 border-yellow-500">
                        <p class="italic text-gray-300">Async/await permite escribir c√≥digo as√≠ncrono que se lee como c√≥digo s√≠ncrono, facilitando la comprensi√≥n del flujo de ejecuci√≥n y mejorando la legibilidad del c√≥digo.</p>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Declaraci√≥n de Funciones Async</h2>
                    <p class="mb-4">Para usar await dentro de una funci√≥n, primero debes declarar esa funci√≥n como async usando la palabra clave <code class="bg-black text-green-400 p-1 rounded">async</code>.</p>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Sintaxis b√°sica:</h3>
                    <pre class="bg-black text-green-400 p-4 rounded overflow-x-auto mb-6"><code>// Funci√≥n declarativa
async function nombreFuncion() {
    // c√≥digo as√≠ncrono aqu√≠
    return valor; // Se convierte impl√≠citamente en Promise.resolve(valor)
}

// Expresi√≥n de funci√≥n
const nombreFuncion = async function() {
    // c√≥digo as√≠ncrono aqu√≠
};

// Funci√≥n flecha
const nombreFuncion = async () => {
    // c√≥digo as√≠ncrono aqu√≠
};

// M√©todos en objetos
const objeto = {
    async metodo() {
        // c√≥digo as√≠ncrono aqu√≠
    }
};

// M√©todos de clase
class MiClase {
    async metodo() {
        // c√≥digo as√≠ncrono aqu√≠
    }
}</code></pre>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Ejemplos:</h3>
                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 1: Funci√≥n async b√°sica</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function obtenerDatos() {
    return "Datos obtenidos";
}

// La funci√≥n async siempre devuelve una promesa
obtenerDatos().then(datos => {
    console.log(datos); // "Datos obtenidos"
});

// Esto es equivalente a:
function obtenerDatosPromesa() {
    return Promise.resolve("Datos obtenidos");
}

obtenerDatosPromesa().then(datos => {
    console.log(datos); // "Datos obtenidos"
});</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 2: Devolver valores en funciones async</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Cualquier valor retornado se envuelve en una promesa
async function obtenerNumero() {
    return 42;
}

obtenerNumero().then(numero => {
    console.log(numero); // 42
});

// Tambi√©n puedes devolver promesas expl√≠citamente
async function obtenerUsuario() {
    // Aqu√≠ fetch ya devuelve una promesa
    const respuesta = await fetch('https://api.ejemplo.com/usuario');
    const usuario = await respuesta.json();
    return usuario; // La promesa se resolver√° con el usuario
}

// O incluso rechazar la promesa con throw
async function verificarAcceso(usuario) {
    if (!usuario.tieneAcceso) {
        throw new Error('Acceso denegado');
        // Equivalente a: return Promise.reject(new Error('Acceso denegado'));
    }
    return 'Acceso concedido';
}</code></pre>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Nota importante:</h4>
                        <p class="text-gray-300">Una funci√≥n async puede no contener await. En este caso, simplemente se ejecutar√° de forma s√≠ncrona pero aun as√≠ devolver√° una promesa. Sin embargo, sin await, pierde gran parte de su prop√≥sito.</p>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">El Operador await</h2>
                    <p class="mb-4">El operador <code class="bg-black text-green-400 p-1 rounded">await</code> pausa la ejecuci√≥n de una funci√≥n async hasta que una promesa se resuelva o rechace, y devuelve el valor resuelto de la promesa.</p>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Sintaxis:</h3>
                    <pre class="bg-black text-green-400 p-4 rounded overflow-x-auto mb-6"><code>async function nombreFuncion() {
    const resultado = await promesa;
    // La ejecuci√≥n se pausa aqu√≠ hasta que promesa se resuelva
    // resultado contiene el valor con el que se resolvi√≥ la promesa
}</code></pre>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Ejemplos:</h3>
                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 1: Await con promesas</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>function esperar(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function ejemplo() {
    console.log("Iniciando...");
    
    // El await pausa la ejecuci√≥n hasta que la promesa se resuelva
    await esperar(2000); // Espera 2 segundos
    
    console.log("Despu√©s de 2 segundos");
    
    await esperar(1000); // Espera 1 segundo m√°s
    
    console.log("Despu√©s de 3 segundos en total");
    
    return "¬°Completado!";
}

// Usar la funci√≥n
ejemplo().then(resultado => {
    console.log(resultado); // "¬°Completado!"
});

console.log("Esto se imprime antes de que ejemplo() termine");</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 2: Await con llamadas a APIs</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function obtenerDatosUsuario(id) {
    // Paso 1: Obtener informaci√≥n del usuario
    const respuestaUsuario = await fetch(`https://api.ejemplo.com/usuarios/${id}`);
    const datosUsuario = await respuestaUsuario.json();
    
    // Paso 2: Obtener los posts del usuario (usando los datos obtenidos)
    const respuestaPosts = await fetch(`https://api.ejemplo.com/usuarios/${datosUsuario.id}/posts`);
    const posts = await respuestaPosts.json();
    
    // Paso 3: Combinar los datos y devolverlos
    return {
        usuario: datosUsuario,
        posts: posts
    };
}

// El c√≥digo de arriba con promesas ser√≠a:
function obtenerDatosUsuarioPromesas(id) {
    return fetch(`https://api.ejemplo.com/usuarios/${id}`)
        .then(respuestaUsuario => respuestaUsuario.json())
        .then(datosUsuario => {
            return fetch(`https://api.ejemplo.com/usuarios/${datosUsuario.id}/posts`)
                .then(respuestaPosts => respuestaPosts.json())
                .then(posts => {
                    return {
                        usuario: datosUsuario,
                        posts: posts
                    };
                });
        });
}</code></pre>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 3: Esperando m√∫ltiples promesas</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Esperar m√∫ltiples promesas secuencialmente
async function secuencial() {
    const resultado1 = await obtenerDato1();
    const resultado2 = await obtenerDato2();
    const resultado3 = await obtenerDato3();
    
    return [resultado1, resultado2, resultado3];
}

// Esperar m√∫ltiples promesas en paralelo
async function paralelo() {
    // Promise.all permite ejecutar todas las promesas a la vez
    const [resultado1, resultado2, resultado3] = await Promise.all([
        obtenerDato1(),
        obtenerDato2(),
        obtenerDato3()
    ]);
    
    return [resultado1, resultado2, resultado3];
}</code></pre>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Restricciones importantes:</h4>
                        <ul class="list-disc pl-6 space-y-1 text-gray-300">
                            <li>El operador <code class="bg-black text-green-400 p-1 rounded">await</code> <strong class="text-white">solo puede usarse dentro de funciones async</strong>.</li>
                            <li>Desde ES2022, tambi√©n es posible usar await en el nivel superior de un m√≥dulo (top-level await).</li>
                            <li>No se puede usar en funciones normales o en el √°mbito global de scripts no modulares.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Manejo de Errores</h2>
                    <p class="mb-4">Una de las grandes ventajas de async/await es que permite manejar errores as√≠ncronos usando el tradicional bloque try/catch, lo que hace el c√≥digo m√°s limpio y f√°cil de entender.</p>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Try/Catch con async/await</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function obtenerDatos() {
    try {
        const respuesta = await fetch('https://api.ejemplo.com/datos');
        
        if (!respuesta.ok) {
            throw new Error(`Error HTTP: ${respuesta.status}`);
        }
        
        const datos = await respuesta.json();
        return datos;
    } catch (error) {
        console.error('Error al obtener datos:', error);
        // Podemos manejar el error y:
        // 1. Devolver un valor por defecto
        return { error: true, mensaje: error.message };
        // 2. O volver a lanzar el error para que lo maneje quien llama a la funci√≥n
        // throw error;
    }
}

// Comparaci√≥n con promesas
function obtenerDatosPromesas() {
    return fetch('https://api.ejemplo.com/datos')
        .then(respuesta => {
            if (!respuesta.ok) {
                throw new Error(`Error HTTP: ${respuesta.status}`);
            }
            return respuesta.json();
        })
        .catch(error => {
            console.error('Error al obtener datos:', error);
            return { error: true, mensaje: error.message };
        });
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Capturar errores espec√≠ficos</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function procesarArchivo(ruta) {
    try {
        const contenido = await leerArchivo(ruta);
        const datos = await procesarDatos(contenido);
        await guardarResultado(datos);
        return true;
    } catch (error) {
        // Podemos manejar diferentes tipos de errores
        if (error instanceof ArchivoNoEncontradoError) {
            console.error(`No se encontr√≥ el archivo: ${ruta}`);
            // Manejar espec√≠ficamente este error
        } else if (error instanceof FormatoInvalidoError) {
            console.error(`El archivo tiene un formato inv√°lido`);
            // Manejar espec√≠ficamente este error
        } else {
            console.error(`Error inesperado: ${error.message}`);
        }
        return false;
    } finally {
        // El bloque finally se ejecuta siempre, haya error o no
        console.log('Procesamiento finalizado');
        // Liberar recursos, cerrar conexiones, etc.
    }
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Errores en bucles as√≠ncronos</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function procesarItems(items) {
    const resultados = [];
    
    for (const item of items) {
        try {
            // Procesar cada item individualmente
            const resultado = await procesarItem(item);
            resultados.push(resultado);
        } catch (error) {
            // Si falla un item, registramos el error pero continuamos con los dem√°s
            console.error(`Error en item ${item}:`, error);
            resultados.push({ item, error: true });
        }
    }
    
    return resultados;
}

// Tambi√©n podemos usar Promise.allSettled para gestionar errores en operaciones paralelas
async function procesarItemsParalelo(items) {
    // Crear un array de promesas
    const promesas = items.map(item => procesarItem(item));
    
    // Promise.allSettled nos da el resultado de todas las promesas,
    // independientemente de si se resolvieron o rechazaron
    const resultados = await Promise.allSettled(promesas);
    
    return resultados.map((resultado, index) => {
        if (resultado.status === 'fulfilled') {
            return resultado.value;
        } else {
            console.error(`Error en item ${items[index]}:`, resultado.reason);
            return { item: items[index], error: true };
        }
    });
}</code></pre>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Nota importante:</h4>
                        <p class="text-gray-300">Si no capturas los errores con try/catch dentro de una funci√≥n async, la promesa que devuelve se rechazar√°. Es importante manejar esos rechazos ya sea:</p>
                        <ul class="list-disc pl-6 space-y-1 mt-2 text-gray-300">
                            <li>Capturando los errores dentro de la funci√≥n async con try/catch, o</li>
                            <li>Usando .catch() cuando llamas a la funci√≥n async desde otro lugar.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Patrones Avanzados</h2>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">1. Ejecutar tareas en paralelo</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function obtenerDatosDePerfil(usuarioId) {
    // Mal: Ejecuci√≥n secuencial (cada llamada espera a que termine la anterior)
    const datosUsuario = await obtenerUsuario(usuarioId);
    const publicaciones = await obtenerPublicaciones(usuarioId);
    const seguidores = await obtenerSeguidores(usuarioId);
    
    return {
        usuario: datosUsuario,
        publicaciones,
        seguidores
    };
}

async function obtenerDatosDePerfilOptimizado(usuarioId) {
    // Mejor: Ejecuci√≥n en paralelo (todas las llamadas inician a la vez)
    const [datosUsuario, publicaciones, seguidores] = await Promise.all([
        obtenerUsuario(usuarioId),
        obtenerPublicaciones(usuarioId),
        obtenerSeguidores(usuarioId)
    ]);
    
    return {
        usuario: datosUsuario,
        publicaciones,
        seguidores
    };
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">2. Procesamiento secuencial de arrays</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Procesar items uno tras otro (secuencial)
async function procesarSecuencial(items) {
    const resultados = [];
    
    for (const item of items) {
        // await dentro del bucle = procesamiento secuencial
        const resultado = await procesarItem(item);
        resultados.push(resultado);
    }
    
    return resultados;
}

// Versi√≥n con reduce para encadenar promesas
async function procesarSecuencialReduce(items) {
    return items.reduce(async (promesaAnterior, item) => {
        // Esperar a que termine el procesamiento anterior
        const resultados = await promesaAnterior;
        // Procesar el item actual
        const resultado = await procesarItem(item);
        return [...resultados, resultado];
    }, Promise.resolve([]));
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">3. Procesamiento paralelo con limitaci√≥n de concurrencia</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Procesar items en paralelo pero con un l√≠mite de concurrencia
async function procesarPorLotes(items, tama√±oLote = 3) {
    const resultados = [];
    
    // Dividir los items en lotes
    for (let i = 0; i < items.length; i += tama√±oLote) {
        const lote = items.slice(i, i + tama√±oLote);
        
        // Procesar un lote en paralelo
        const resultadosLote = await Promise.all(
            lote.map(item => procesarItem(item))
        );
        
        resultados.push(...resultadosLote);
    }
    
    return resultados;
}

// Implementaci√≥n m√°s avanzada con concurrencia controlada
async function procesarConConcurrencia(items, limiteConcurrencia = 3) {
    const pendientes = [...items];
    const resultados = [];
    
    // Crear un conjunto inicial de promesas
    const promesasActivas = new Set();
    
    // Funci√≥n para crear y ejecutar una tarea
    async function ejecutarTarea() {
        // Tomar el siguiente item pendiente
        const item = pendientes.shift();
        
        // Procesar el item
        try {
            const resultado = await procesarItem(item);
            resultados.push(resultado);
        } catch (error) {
            console.error(`Error procesando item ${item}:`, error);
            resultados.push({ item, error: true });
        }
        
        // Eliminar esta promesa del conjunto de activas
        promesasActivas.delete(promise);
        
        // Si quedan items pendientes, iniciar una nueva tarea
        if (pendientes.length > 0) {
            const nuevaPromesa = ejecutarTarea();
            promesasActivas.add(nuevaPromesa);
        }
    }
    
    // Iniciar el n√∫mero de tareas seg√∫n el l√≠mite de concurrencia
    const tareasPorIniciar = Math.min(limiteConcurrencia, items.length);
    
    for (let i = 0; i < tareasPorIniciar; i++) {
        const promesa = ejecutarTarea();
        promesasActivas.add(promesa);
    }
    
    // Esperar a que todas las tareas terminen
    await Promise.all(promesasActivas);
    
    return resultados;
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">4. Timeout para operaciones as√≠ncronas</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Funci√≥n para establecer un timeout en una promesa
function conTimeout(promesa, ms) {
    // Crear una promesa de timeout
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error(`Operaci√≥n cancelada por timeout despu√©s de ${ms}ms`));
        }, ms);
    });
    
    // Usar Promise.race para competir entre la promesa original y el timeout
    return Promise.race([promesa, timeoutPromise]);
}

// Uso con async/await
async function obtenerDatos() {
    try {
        // Establecer un timeout de 5 segundos
        const datos = await conTimeout(fetch('https://api.ejemplo.com/datos'), 5000);
        return await datos.json();
    } catch (error) {
        console.error('Error:', error.message);
        throw error; // O manejar de otra forma
    }
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">5. Retry autom√°tico</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Funci√≥n para reintentar una operaci√≥n as√≠ncrona
async function conReintentos(operacion, maxIntentos = 3, retraso = 1000) {
    let ultimoError;
    
    for (let intento = 1; intento <= maxIntentos; intento++) {
        try {
            return await operacion();
        } catch (error) {
            ultimoError = error;
            console.warn(`Intento ${intento}/${maxIntentos} fall√≥: ${error.message}`);
            
            if (intento < maxIntentos) {
                // Esperar antes del siguiente intento (opcional: retraso exponencial)
                const tiempoEspera = retraso * Math.pow(2, intento - 1);
                console.log(`Esperando ${tiempoEspera}ms antes del siguiente intento...`);
                await new Promise(resolve => setTimeout(resolve, tiempoEspera));
            }
        }
    }
    
    // Si llegamos aqu√≠, todos los intentos fallaron
    throw new Error(`Despu√©s de ${maxIntentos} intentos: ${ultimoError.message}`);
}

// Uso
async function obtenerDatos() {
    try {
        const resultado = await conReintentos(
            async () => {
                const respuesta = await fetch('https://api.ejemplo.com/datos');
                if (!respuesta.ok) {
                    throw new Error(`HTTP error: ${respuesta.status}`);
                }
                return respuesta.json();
            },
            3,  // m√°ximo 3 intentos
            1000 // esperar 1 segundo entre intentos (1s, 2s, 4s)
        );
        
        return resultado;
    } catch (error) {
        console.error('Error final:', error.message);
        // Manejar el error definitivo
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

<section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Async/Await en Bucles</h2>
                    <p class="mb-4">El uso de async/await en bucles requiere atenci√≥n especial, ya que hay diferencias importantes en c√≥mo se ejecuta el c√≥digo seg√∫n el tipo de bucle y d√≥nde se coloca el await.</p>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">For cl√°sico vs forEach</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>async function procesarArrayForClassico(items) {
    // ‚úÖ Correcto: await dentro de un bucle for espera a que cada promesa termine
    for (let i = 0; i < items.length; i++) {
        await procesarItem(items[i]);
        console.log(`Item ${i} procesado`);
    }
}

async function procesarArrayForEach(items) {
    // ‚ö†Ô∏è Problema: forEach no espera a las promesas
    // Este c√≥digo NO funcionar√° como se espera
    items.forEach(async (item) => {
        await procesarItem(item);
        console.log(`Item ${item} procesado`);
    });
    console.log('Todos procesados'); // Se imprime antes de que los items se procesen
}

// ‚úÖ Alternativa a forEach: usar Promise.all con map
async function procesarArrayMap(items) {
    await Promise.all(items.map(async (item) => {
        await procesarItem(item);
        console.log(`Item ${item} procesado`);
    }));
    console.log('Todos procesados'); // Ahora s√≠ espera a que terminen
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Procesar secuencialmente vs paralelamente</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Secuencial: un item a la vez
async function procesarSecuencial(items) {
    const resultados = [];
    
    for (const item of items) {
        // El await dentro del bucle hace que se procese un item tras otro
        const resultado = await procesarItem(item);
        resultados.push(resultado);
    }
    
    return resultados;
}

// Paralelo: todos los items a la vez
async function procesarParalelo(items) {
    // Generar todas las promesas de una vez sin esperar
    const promesas = items.map(item => procesarItem(item));
    
    // Esperar a que todas terminen
    const resultados = await Promise.all(promesas);
    
    return resultados;
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Uso de for...of y for...in</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// for...of funciona bien con await (iteraci√≥n sobre valores)
async function procesarConForOf(items) {
    for (const item of items) {
        // Espera a que se procese cada item antes de pasar al siguiente
        await procesarItem(item);
    }
}

// for...in con objetos (iteraci√≥n sobre propiedades)
async function procesarObjetoConForIn(objeto) {
    for (const clave in objeto) {
        if (Object.hasOwnProperty.call(objeto, clave)) {
            // Espera a que se procese cada propiedad antes de pasar a la siguiente
            await procesarPropiedad(clave, objeto[clave]);
        }
    }
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Consideraciones de rendimiento</h4>
                            <p class="mb-2">Elegir entre procesamiento secuencial y paralelo depende de varios factores:</p>
                            <ul class="list-disc pl-6 space-y-1">
                                <li><strong class="text-white">Secuencial:</strong> Cuando el orden importa o cuando una operaci√≥n depende del resultado de la anterior.</li>
                                <li><strong class="text-white">Paralelo:</strong> Cuando las operaciones son independientes y buscas mayor velocidad.</li>
                                <li><strong class="text-white">Concurrencia limitada:</strong> Para balancear velocidad y uso de recursos (como se mostr√≥ en patrones avanzados).</li>
                            </ul>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Resumen:</h4>
                        <ul class="list-disc pl-6 space-y-1 text-gray-300">
                            <li>‚úÖ <code class="bg-black text-green-400 p-1 rounded">for</code>, <code class="bg-black text-green-400 p-1 rounded">for...of</code>, <code class="bg-black text-green-400 p-1 rounded">for...in</code>, <code class="bg-black text-green-400 p-1 rounded">while</code>: Funcionan bien con await.</li>
                            <li>‚ùå <code class="bg-black text-green-400 p-1 rounded">forEach</code>, <code class="bg-black text-green-400 p-1 rounded">map</code>, <code class="bg-black text-green-400 p-1 rounded">filter</code>, etc.: No esperan a promesas por s√≠ solos.</li>
                            <li>‚úÖ <code class="bg-black text-green-400 p-1 rounded">Promise.all()</code> con <code class="bg-black text-green-400 p-1 rounded">map</code>: Mejor manera de procesar arrays en paralelo.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Top-level await</h2>
                    <p class="mb-4">A partir de ECMAScript 2022, es posible usar <code class="bg-black text-green-400 p-1 rounded">await</code> fuera de funciones async, directamente en el nivel superior (top-level) de un m√≥dulo.</p>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">¬øQu√© es top-level await?</h4>
                            <p class="mb-2">Top-level await permite usar el operador await fuera de funciones async, pero solo en m√≥dulos ES (archivos JavaScript cargados como type="module" o con la extensi√≥n .mjs).</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-3"><code>// En un archivo de m√≥dulo ES (.js con type="module" o .mjs)

// Importaci√≥n as√≠ncrona de m√≥dulos
const modulo = await import('./modulo-dinamico.js');

// Cargar datos antes de que el m√≥dulo est√© disponible
const datos = await fetch('https://api.ejemplo.com/datos').then(r => r.json());

// Uso de los datos para inicializar el m√≥dulo
export const configuracion = {
    api: datos.apiEndpoint,
    clave: datos.apiKey
};

// Inicializar la base de datos antes de exportar m√≥dulos
const conexion = await inicializarBaseDeDatos();
export { conexion };</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ventajas de top-level await</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>Permite inicializar m√≥dulos con operaciones as√≠ncronas</li>
                                <li>Simplifica la carga de recursos antes de que el m√≥dulo est√© disponible</li>
                                <li>Evita patrones complejos de inicializaci√≥n as√≠ncrona</li>
                                <li>Hace que el c√≥digo sea m√°s limpio y directo para operaciones as√≠ncronas necesarias</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Comportamiento en la importaci√≥n de m√≥dulos</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// moduleA.js
console.log("M√≥dulo A: inicio");
await new Promise(resolve => setTimeout(resolve, 1000));
console.log("M√≥dulo A: despu√©s de esperar");
export const valorA = "A";

// moduleB.js
import { valorA } from './moduleA.js';
console.log("M√≥dulo B cargado, valorA:", valorA);

// index.js
console.log("Inicio del programa");
import './moduleB.js';
console.log("Fin del programa");

// Salida:
// "M√≥dulo A: inicio"
// (espera 1 segundo)
// "M√≥dulo A: despu√©s de esperar"
// "M√≥dulo B cargado, valorA: A"
// "Inicio del programa"
// "Fin del programa"</code></pre>
                            <p class="mt-2 text-gray-300">Cuando un m√≥dulo usa top-level await, los m√≥dulos que lo importan esperan a que termine antes de ejecutar su propio c√≥digo.</p>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Limitaciones:</h4>
                        <ul class="list-disc pl-6 space-y-1 text-gray-300">
                            <li>Solo funciona en m√≥dulos ES, no en scripts normales</li>
                            <li>Puede causar bloqueos en la carga de m√≥dulos si no se usa con cuidado</li>
                            <li>El soporte en navegadores y entornos antiguos puede ser limitado</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Buenas Pr√°cticas</h2>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Siempre usar try/catch</h4>
                            <p>Capturar errores en todas las operaciones as√≠ncronas para evitar rechazos de promesas no manejados.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚úÖ Buena pr√°ctica
async function obtenerDatos() {
    try {
        const datos = await fetch('/api/datos');
        return await datos.json();
    } catch (error) {
        console.error('Error:', error);
        throw error; // O manejar de otra forma
    }
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Evitar await innecesarios</h4>
                            <p>No usar await cuando no es necesario esperar por el resultado.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚ùå Mala pr√°ctica: await innecesario
async function procesarYEnviar(datos) {
    const resultado = procesarDatos(datos); // No es as√≠ncrono
    await guardarDatos(resultado); // Es as√≠ncrono
    // No esperamos por el resultado de enviar
    await enviarNotificacion(resultado);
}

// ‚úÖ Mejor: Solo usar await donde es necesario
async function procesarYEnviar(datos) {
    const resultado = procesarDatos(datos);
    await guardarDatos(resultado);
    // Si no necesitamos esperar a que termine:
    enviarNotificacion(resultado); // Sin await
    return resultado;
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Aprovechar el paralelismo</h4>
                            <p>Cuando sea posible, ejecutar operaciones as√≠ncronas en paralelo para mejorar el rendimiento.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚ùå Mala pr√°ctica: Serial innecesario
async function obtenerTodo() {
    const usuarios = await obtenerUsuarios();
    const productos = await obtenerProductos();
    const pedidos = await obtenerPedidos();
    return { usuarios, productos, pedidos };
}

// ‚úÖ Mejor: Paralelismo
async function obtenerTodo() {
    const [usuarios, productos, pedidos] = await Promise.all([
        obtenerUsuarios(),
        obtenerProductos(),
        obtenerPedidos()
    ]);
    return { usuarios, productos, pedidos };
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Evitar funciones async innecesarias</h4>
                            <p>No crear funciones async si no usas await dentro de ellas.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚ùå Mala pr√°ctica: async innecesario
async function obtenerNombre() {
    return "Juan"; // No hay await, no necesita ser async
}

// ‚úÖ Mejor: Funci√≥n normal
function obtenerNombre() {
    return "Juan";
}

// ‚ùå Mala pr√°ctica: Envolver una promesa en async/await sin necesidad
async function obtenerDatos() {
    return await fetch('/api/datos').then(r => r.json());
}

// ‚úÖ Mejor: Retornar la promesa directamente
function obtenerDatos() {
    return fetch('/api/datos').then(r => r.json());
}

// ‚úÖ O si necesitas async para manejo de errores:
async function obtenerDatos() {
    const respuesta = await fetch('/api/datos');
    return respuesta.json();
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Nombrar adecuadamente las funciones async</h4>
                            <p>Usar nombres que indiquen que la funci√≥n es as√≠ncrona para mejorar la legibilidad.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚ùå Nombres que no revelan asincron√≠a
async function datosUsuario() {...}
async function validacion() {...}

// ‚úÖ Nombres que indican asincron√≠a
async function obtenerDatosUsuario() {...}
async function validarCredenciales() {...}
async function cargarConfiguracion() {...}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Mantener funciones async peque√±as y enfocadas</h4>
                            <p>Dividir funciones async grandes en componentes m√°s peque√±os para mejorar la legibilidad y el mantenimiento.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// ‚ùå Funci√≥n grande y compleja
async function procesarPedido(pedidoId) {
    // 50+ l√≠neas de c√≥digo con m√∫ltiples responsabilidades
}

// ‚úÖ Divido en funciones m√°s peque√±as
async function procesarPedido(pedidoId) {
    const pedido = await obtenerPedido(pedidoId);
    const existencias = await verificarInventario(pedido.items);
    
    if (existencias.todoDisponible) {
        await actualizarInventario(pedido.items);
        await cobrarAlCliente(pedido);
        await generarFactura(pedido);
        await enviarConfirmacion(pedido);
    } else {
        await notificarFaltantes(pedido, existencias.faltantes);
    }
    
    return { procesado: existencias.todoDisponible };
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Compatibilidad en Navegadores</h2>
                    <p class="mb-4">Async/await es una caracter√≠stica relativamente moderna de JavaScript, por lo que es importante considerar la compatibilidad en navegadores y entornos antiguos.</p>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Soporte en navegadores:</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li><strong class="text-white">Navegadores modernos:</strong> Soporte completo en Chrome 55+, Firefox 52+, Safari 11+, Edge 15+</li>
                                <li><strong class="text-white">Internet Explorer:</strong> No soportado nativamente en ninguna versi√≥n</li>
                                <li><strong class="text-white">Top-level await:</strong> Soporte m√°s limitado (Chrome 89+, Firefox 89+, Safari 15+)</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Opciones para compatibilidad:</h4>
                            <ul class="list-disc pl-6 space-y-2">
                                <li><strong class="text-white">Transpilaci√≥n:</strong> Usar Babel para convertir c√≥digo async/await a promesas o generadores</li>
                                <li><strong class="text-white">Polyfills:</strong> Incluir regenerator-runtime para soporte en navegadores antiguos</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo de configuraci√≥n Babel:</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// .babelrc
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "browsers": ["last 2 versions", "ie >= 11"]
      }
    }]
  ]
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">C√≥mo se transpila async/await:</h4>
                            <div class="grid grid-cols-1 md:grid-cols-1 gap-4">
                                <div>
                                    <h5 class="text-sm font-medium mb-1 text-gray-400">C√≥digo ES2017+:</h5>
                                    <pre class="bg-black text-green-400 p-2 rounded overflow-x-auto"><code>async function obtenerDatos() {
  try {
    const respuesta = await fetch('/api/datos');
    const datos = await respuesta.json();
    return datos;
  } catch (error) {
    console.error(error);
    return null;
  }
}</code></pre>
                                </div>
                                <div>
                                    <h5 class="text-sm font-medium mb-1 text-gray-400">Transpilado a ES5:</h5>
                                    <pre class="bg-black text-green-400 p-2 rounded overflow-x-auto"><code>function obtenerDatos() {
  return regeneratorRuntime.async(function obtenerDatos$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return regeneratorRuntime.awrap(fetch('/api/datos'));
        case 3:
          respuesta = _context.sent;
          _context.next = 6;
          return regeneratorRuntime.awrap(respuesta.json());
        case 6:
          datos = _context.sent;
          return _context.abrupt("return", datos);
        case 10:
          // ... (c√≥digo para manejo de errores)
      }
    }
  }, null, null, [[0, 10]]);
}</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Recomendaci√≥n:</h4>
                        <p class="text-gray-300">Si necesitas soporte para navegadores antiguos, aseg√∫rate de usar un proceso de build con Babel y los polyfills adecuados. Herramientas como webpack, Parcel o Vite pueden configurarse para manejar esto autom√°ticamente.</p>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Recursos Adicionales</h2>
                    <ul class="list-disc pl-6 space-y-2">
                        <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/async_function" class="text-yellow-400 hover:text-yellow-300">MDN Web Docs - Funci√≥n async</a></li>
                        <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/await" class="text-yellow-400 hover:text-yellow-300">MDN Web Docs - Operador await</a></li>
                        <li><a href="https://es.javascript.info/async-await" class="text-yellow-400 hover:text-yellow-300">JavaScript.info - Async/await</a></li>
                        <li><a href="https://www.w3schools.com/js/js_async.asp" class="text-yellow-400 hover:text-yellow-300">W3Schools - JavaScript Async</a></li>
                    </ul>
                </div>
            </section>
        </div>
    </div>
</body>
</html>