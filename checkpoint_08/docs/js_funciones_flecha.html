<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üü®</text></svg>" />
    <title>Funciones de Flecha en JavaScript - Documentaci√≥n</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex flex-col min-h-screen">
    <header class="bg-yellow-600 text-white text-center py-12 px-4 shadow-md fixed top-0 left-0 right-0 z-20">
        <h1 class="text-4xl font-bold mb-2">Funciones de Flecha en JavaScript</h1>
        <p class="text-xl">¬øQu√© es una funci√≥n de flecha?</p>
    </header>

    <nav class="bg-gray-800 py-4 px-6 shadow-md fixed top-40 left-0 right-0 z-10 border-b border-gray-700">
        <a href="../index.html" class="text-yellow-400 hover:text-yellow-300 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
            Volver al √≠ndice
        </a>
    </nav>

    <div class="pt-56">

        <div class="container mx-auto px-4 py-8 max-w-4xl flex-grow">
            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">¬øQu√© son las Funciones de Flecha?</h2>
                    <p class="mb-4">Las funciones de flecha (arrow functions) son una sintaxis m√°s concisa para escribir funciones en JavaScript, introducidas en ES6 (ECMAScript 2015). Ofrecen una forma m√°s corta de definir funciones y tienen diferencias importantes en c√≥mo manejan el √°mbito de <code class="bg-black text-green-400 p-1 rounded">this</code> respecto a las funciones tradicionales.</p>
                    
                    <div class="bg-gray-900 p-4 rounded-lg mb-6 border border-yellow-700">
                        <h3 class="text-lg font-semibold mb-2 text-yellow-300">Caracter√≠sticas principales:</h3>
                        <ul class="list-disc pl-6 space-y-2 text-gray-300">
                            <li><strong class="text-white">Sintaxis concisa:</strong> Menos c√≥digo para funciones simples</li>
                            <li><strong class="text-white">Sin binding propio de this:</strong> El valor de <code class="bg-black text-green-400 p-1 rounded">this</code> se hereda del contexto contenedor</li>
                            <li><strong class="text-white">No tiene arguments:</strong> No existe el objeto <code class="bg-black text-green-400 p-1 rounded">arguments</code>, pero se pueden usar par√°metros rest</li>
                            <li><strong class="text-white">No se pueden usar como constructores:</strong> No se pueden llamar con <code class="bg-black text-green-400 p-1 rounded">new</code></li>
                            <li><strong class="text-white">No tienen prototype:</strong> No tienen la propiedad <code class="bg-black text-green-400 p-1 rounded">prototype</code></li>
                        </ul>
                    </div>
                    
                    <p class="mb-4">Las funciones flecha son especialmente √∫tiles para funciones cortas, callbacks y cuando se necesita mantener el contexto de <code class="bg-black text-green-400 p-1 rounded">this</code> del √°mbito contenedor.</p>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Sintaxis B√°sica</h2>
                    <p class="mb-4">La sintaxis de las funciones flecha es mucho m√°s concisa que la de funciones tradicionales, y tiene varias formas dependiendo de la complejidad.</p>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Sintaxis:</h3>
                    <pre class="bg-black text-green-400 p-4 rounded overflow-x-auto mb-6"><code>// Forma b√°sica
(parametros) => { sentencias }

// Con un solo par√°metro, los par√©ntesis son opcionales
parametro => { sentencias }

// Sin par√°metros, los par√©ntesis son obligatorios
() => { sentencias }

// Retorno impl√≠cito (sin llaves)
(parametros) => expresion

// Retorno de un objeto literal (requiere par√©ntesis para evitar ambig√ºedad)
(parametros) => ({ propiedad: valor })</code></pre>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Ejemplos:</h3>
                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 1: Funci√≥n tradicional vs funci√≥n flecha</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Funci√≥n tradicional
function sumar(a, b) {
    return a + b;
}

// Equivalente con funci√≥n flecha
const sumarFlecha = (a, b) => {
    return a + b;
};

// Versi√≥n a√∫n m√°s concisa con retorno impl√≠cito
const sumarConciso = (a, b) => a + b;

console.log(sumar(5, 3));        // 8
console.log(sumarFlecha(5, 3));  // 8
console.log(sumarConciso(5, 3)); // 8</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 2: Par√°metros y retornos</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Sin par√°metros
const saludar = () => "¬°Hola, mundo!";
console.log(saludar()); // ¬°Hola, mundo!

// Un solo par√°metro (par√©ntesis opcionales)
const cuadrado = x => x * x;
console.log(cuadrado(4)); // 16

// Retornando un objeto literal (requiere par√©ntesis)
const crearPersona = (nombre, edad) => ({ nombre, edad });
console.log(crearPersona("Ana", 28)); // { nombre: "Ana", edad: 28 }

// M√∫ltiples l√≠neas requieren llaves y return expl√≠cito
const calcularArea = (ancho, alto) => {
    const area = ancho * alto;
    return `El √°rea es ${area} metros cuadrados`;
};
console.log(calcularArea(5, 3)); // El √°rea es 15 metros cuadrados</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">El valor de 'this' en Funciones Flecha</h2>
                    <p class="mb-4">Una de las principales diferencias entre las funciones flecha y las funciones tradicionales es c√≥mo manejan el valor de <code class="bg-black text-green-400 p-1 rounded">this</code>. En las funciones flecha, <code class="bg-black text-green-400 p-1 rounded">this</code> est√° l√©xicamente vinculado al contexto circundante.</p>
                    
                    <h3 class="text-lg font-semibold mb-2 text-yellow-300">Comportamiento en funciones tradicionales vs flecha:</h3>
                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 1: this en m√©todos de objetos</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>const persona = {
    nombre: "Carlos",
    // M√©todo con funci√≥n tradicional
    saludarTradicional: function() {
        console.log(`Hola, soy ${this.nombre}`);
    },
    // M√©todo con funci√≥n flecha
    saludarFlecha: () => {
        console.log(`Hola, soy ${this.nombre}`);
    }
};

persona.saludarTradicional(); // "Hola, soy Carlos"
persona.saludarFlecha();      // "Hola, soy undefined" (this no se refiere a persona)</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 2: this en callbacks</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>function Contador() {
    this.valor = 0;
    
    // Usando funci√≥n tradicional (pierde el this)
    setInterval(function() {
        this.valor++;  // this se refiere a window, no a Contador
        console.log(this.valor);  // NaN
    }, 1000);
}

function ContadorMejorado() {
    this.valor = 0;
    
    // Usando funci√≥n flecha (mantiene el this del contexto)
    setInterval(() => {
        this.valor++;  // this se refiere a ContadorMejorado
        console.log(this.valor);  // 1, 2, 3, ...
    }, 1000);
}</code></pre>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Ejemplo 3: Soluci√≥n tradicional vs flecha</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>const equipo = {
    miembros: ["Ana", "Luis", "Carlos"],
    nombre: "Innovadores",
    
    // M√©todo con funci√≥n tradicional y workaround con that/self
    mostrarMiembrosTradicional: function() {
        const that = this;  // Guardar referencia a this
        return this.miembros.map(function(miembro) {
            return `${miembro} es del equipo ${that.nombre}`;
        });
    },
    
    // M√©todo con funci√≥n flecha (m√°s elegante)
    mostrarMiembrosFlecha: function() {
        return this.miembros.map(miembro => 
            `${miembro} es del equipo ${this.nombre}`
        );
    }
};

console.log(equipo.mostrarMiembrosTradicional());
console.log(equipo.mostrarMiembrosFlecha());</code></pre>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-4 rounded-lg mt-6 border border-yellow-700">
                        <h4 class="font-medium mb-2 text-yellow-200">Advertencia:</h4>
                        <p class="text-gray-300">Por su comportamiento con <code class="bg-black text-green-400 p-1 rounded">this</code>, las funciones flecha no son adecuadas para ser m√©todos de objetos, manejadores de eventos que usen <code class="bg-black text-green-400 p-1 rounded">this</code>, constructores, o funciones que usen <code class="bg-black text-green-400 p-1 rounded">arguments</code>.</p>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Limitaciones de las Funciones Flecha</h2>
                    <p class="mb-4">A pesar de sus ventajas, las funciones flecha tienen ciertas limitaciones que debes conocer para usarlas correctamente.</p>
                    
                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">1. No tienen objeto arguments</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>function funcionTradicional() {
    console.log(arguments);  // [1, 2, 3, callee: ∆í, Symbol(Symbol.iterator): ∆í]
}

const funcionFlecha = () => {
    console.log(arguments);  // ReferenceError o referencia al arguments del contexto externo
};

funcionTradicional(1, 2, 3);

// Soluci√≥n: Usar par√°metros rest
const funcionFlechaRest = (...args) => {
    console.log(args);  // [1, 2, 3]
};

funcionFlechaRest(1, 2, 3);</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">2. No se pueden usar como constructores</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>function Persona(nombre) {
    this.nombre = nombre;
}

const persona1 = new Persona("Ana");  // OK

const PersonaFlecha = (nombre) => {
    this.nombre = nombre;
};

// const persona2 = new PersonaFlecha("Carlos");  
// Error: PersonaFlecha is not a constructor</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">3. No tienen prototype</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>function Tradicional() {}
console.log(Tradicional.prototype);  // {constructor: ∆í}

const Flecha = () => {};
console.log(Flecha.prototype);  // undefined</code></pre>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">4. No pueden usar yield</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Las funciones flecha no pueden ser generadoras
function* generadorTradicional() {
    yield 1;
    yield 2;
}

// Esto causar√≠a un error de sintaxis
// const generadorFlecha = *() => {
//     yield 1;
//     yield 2;
// };</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Usos Comunes de Funciones Flecha</h2>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">1. Callbacks en m√©todos de array</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>const numeros = [1, 2, 3, 4, 5];

// map con funci√≥n flecha
const cuadrados = numeros.map(n => n * n);
console.log(cuadrados);  // [1, 4, 9, 16, 25]

// filter con funci√≥n flecha
const pares = numeros.filter(n => n % 2 === 0);
console.log(pares);  // [2, 4]

// reduce con funci√≥n flecha
const suma = numeros.reduce((total, n) => total + n, 0);
console.log(suma);  // 15</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">2. Funciones inmediatamente invocadas (IIFE)</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// IIFE tradicional
(function() {
    console.log("IIFE tradicional ejecutada");
})();

// IIFE con funci√≥n flecha
(() => {
    console.log("IIFE con flecha ejecutada");
})();</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">3. En operaciones as√≠ncronas</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>// Promesa con funci√≥n flecha
const fetchDatos = () => {
    return fetch('https://api.ejemplo.com/datos')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            return data;
        })
        .catch(error => console.error('Error:', error));
};

// Async/await con funci√≥n flecha
const fetchDatosAsync = async () => {
    try {
        const response = await fetch('https://api.ejemplo.com/datos');
        const data = await response.json();
        console.log(data);
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
};</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">4. En closures</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>const crearContador = () => {
    let contador = 0;
    return () => {
        contador++;
        return contador;
    };
};

const contar = crearContador();
console.log(contar());  // 1
console.log(contar());  // 2
console.log(contar());  // 3</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Buenas Pr√°cticas</h2>
                    
                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Cu√°ndo usar funciones flecha</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>Para funciones cortas y expresiones simples</li>
                                <li>En callbacks donde no necesitas manejar <code class="bg-black text-green-400 p-1 rounded">this</code> espec√≠ficamente</li>
                                <li>Para mantener el contexto de <code class="bg-black text-green-400 p-1 rounded">this</code> del √°mbito padre</li>
                                <li>En los m√©todos de arrays como map, filter, reduce, etc.</li>
                                <li>Para funciones de una sola l√≠nea con retorno impl√≠cito</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Cu√°ndo NO usar funciones flecha</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>Como m√©todos de objetos (cuando necesitas acceder a <code class="bg-black text-green-400 p-1 rounded">this</code> del objeto)</li>
                                <li>En constructores (con <code class="bg-black text-green-400 p-1 rounded">new</code>)</li>
                                <li>En funciones que usan el objeto <code class="bg-black text-green-400 p-1 rounded">arguments</code></li>
                                <li>En funciones generadoras (con <code class="bg-black text-green-400 p-1 rounded">yield</code>)</li>
                                <li>En manejadores de eventos DOM donde <code class="bg-black text-green-400 p-1 rounded">this</code> debe referirse al elemento</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">Consistencia en el estilo</h4>
                            <p>Es importante mantener un estilo consistente en tu c√≥digo. Si decides usar funciones flecha para callbacks, intenta mantener esta convenci√≥n en todo tu proyecto. Esto mejora la legibilidad y mantenibilidad.</p>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto mt-2"><code>// Consistente (todos usan funci√≥n flecha)
const numeros = [1, 2, 3, 4, 5];
const duplicados = numeros.map(n => n * 2);
const pares = duplicados.filter(n => n % 2 === 0);
const suma = pares.reduce((total, n) => total + n, 0);

// Inconsistente (mezcla de estilos)
const duplicados = numeros.map(n => n * 2);
const pares = duplicados.filter(function(n) {
    return n % 2 === 0;
});
const suma = pares.reduce((total, n) => total + n, 0);</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Compatibilidad en Navegadores</h2>
                    <p class="mb-4">Las funciones flecha son una caracter√≠stica de ES6 (ECMAScript 2015) y son compatibles con todos los navegadores modernos. Sin embargo, no son compatibles con versiones antiguas de navegadores como Internet Explorer.</p>
                    
                    <div class="bg-gray-900 p-4 rounded-lg mb-6">
                        <h4 class="font-medium mb-2 text-yellow-200">Opciones para compatibilidad:</h4>
                        <ul class="list-disc pl-6 space-y-2">
                            <li><strong class="text-white">Transpilaci√≥n:</strong> Usa herramientas como Babel para convertir c√≥digo ES6 a ES5 compatible con navegadores antiguos</li>
                            <li><strong class="text-white">Polyfills:</strong> Bibliotecas que a√±aden funcionalidad a navegadores antiguos</li>
                        </ul>
                    </div>
                    
                    <p class="mb-4">Ejemplo de c√≥digo ES6 transpilado a ES5:</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">C√≥digo ES6 (con funci√≥n flecha)</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>const doble = (n) => n * 2;

[1, 2, 3].map(n => n * 2);</code></pre>
                        </div>
                        
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="font-medium mb-2 text-yellow-200">C√≥digo transpilado a ES5</h4>
                            <pre class="bg-black text-green-400 p-3 rounded overflow-x-auto"><code>var doble = function(n) {
    return n * 2;
};

[1, 2, 3].map(function(n) {
    return n * 2;
});</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-6 pb-2 border-b-2 border-yellow-500">Recursos Adicionales</h2>
                    <ul class="list-disc pl-6 space-y-2">
                        <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Functions/Arrow_functions" class="text-yellow-400 hover:text-yellow-300">MDN Web Docs - Funciones flecha</a></li>
                        <li><a href="https://es.javascript.info/arrow-functions" class="text-yellow-400 hover:text-yellow-300">JavaScript.info - Funciones flecha, lo b√°sico</a></li>
                        <li><a href="https://www.w3schools.com/js/js_arrow_function.asp" class="text-yellow-400 hover:text-yellow-300">W3Schools - JavaScript Arrow Functions</a></li>
                    </ul>
                </div>
            </section>
        </div>
    </div>
</body>
</html>